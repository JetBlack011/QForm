

# This file was *autogenerated* from the file qform.sage
from sage.all_cmdline import *   # import sage library

_sage_const_2 = Integer(2); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_8 = Integer(8)
import numpy as np

# Genus
g = _sage_const_2 

# Intersection matrices of the form
# [[<a_1, b_1>, ..., <a_1, b_g>],
#  [     ⁞    ,  ⋱ ,     ⁞     ],
#  [<a_g, b_1>, ..., <a_g, b_g>]]
#mats = [
#    [[1,2],[2,1]],   # a,b
#    [[3,4],[-1,-2]], # a,c
#    [[-1,-2],[3,4]], # a,d
#    [[4,5],[6,7]],   # b,c
#    [[0,1],[1,0]],   # b,d
#    [[1,5],[-2,-3]], # c,d
#]

#mats = [
#    [[1,2,3],[4,5,6],[2,1,3]],       # a,b
#    [[3,4,5],[6,7,8],[-1,-2,-3]],    # a,c
#    [[-1,-2,-3],[-4,-5,-6],[3,4,5]], # a,d
#    [[4,5,6],[7,8,9],[6,7,8]],       # b,c
#    [[0,1,2],[3,4,5],[1,0,-1]],      # b,d
#    [[1,5,9],[2,3,4],[-2,-3,-4]],    # c,d
#]

mats = [
    [[_sage_const_1 , _sage_const_0 ], [_sage_const_0 , _sage_const_1 ]], # a, b
    [[_sage_const_1 , _sage_const_0 ], [_sage_const_0 , _sage_const_1 ]], # a, c
    [[_sage_const_0 , _sage_const_1 ], [_sage_const_1 , _sage_const_0 ]], # b, c
]

def ind(a, b):
    return a + b - _sage_const_1 

def uncount(l):
    # Turns out this is the right expression o.O
    return int((-_sage_const_1  + sqrt(_sage_const_1  + _sage_const_8  * float(l))) / _sage_const_2 )

mats = list(map(matrix, mats))

# Generate our base intersection matrix
blocks = []
n = uncount(len(mats)) + _sage_const_1 
print(n)
for i in range(n):
    blocks.append([])
    for j in range(n):
        if i == j:
            blocks[i].append(matrix(g))
        elif i > j:
            blocks[i].append(-mats[ind(i, j)].transpose())
        else:
            blocks[i].append(mats[ind(i, j)])

blocks_ = []
for i in range(g):
    blocks_.append([])
    for j in range(g):
        blocks_[i].append(blocks[i][j])

I = block_matrix(blocks)
A = block_matrix(blocks_)

print(f'{I}\n')
#print(f'{A}\n')

# Build the kernel of our map
ker = [[] for _ in range(g * (n - g))]

for i in range(g, n):
    for j in range(g):
        coeffs = np.linalg.solve(
            A,
            [blocks[a][i][k][j] for a in range(g) for k in range(g)]
        ).tolist()
        ker[i-g+j].extend(coeffs)
        ker[i-g+j].extend(np.zeros(g * (n - g)).tolist())
        ker[i-g+j][g*g+j] = -_sage_const_1 

print(f'Kernel is generated by\n{matrix(ker)}\n')

# Compute the intersection form
Q = []

for a in range(g):
    Q.append([])
    for b in range(g):
        s = _sage_const_0 
        for i in range(len(ker[a])):
            for j in range(i, len(ker[b])):
                s += (ker[a][i] * ker[b][j]) * I[i][j]
        Q[a].append(s)

print(f'Q =\n{matrix(Q)}')

