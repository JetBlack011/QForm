

# This file was *autogenerated* from the file qform.sage
from sage.all_cmdline import *   # import sage library

_sage_const_4 = Integer(4); _sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_8 = Integer(8); _sage_const_10 = Integer(10); _sage_const_3 = Integer(3)
from functools import reduce
import numpy as np
import random

I4 = matrix.identity(_sage_const_4 )
J = matrix([[_sage_const_0 , _sage_const_0 , _sage_const_1 , _sage_const_0 ], [_sage_const_0 , _sage_const_0 , _sage_const_0 , _sage_const_1 ], [-_sage_const_1 , _sage_const_0 , _sage_const_0 , _sage_const_0 ], [_sage_const_0 , -_sage_const_1 , _sage_const_0 , _sage_const_0 ]])
Sp4 = Sp(_sage_const_4 , ZZ, invariant_form=J)

def _ind(y, x, l, n):
    return l - (n - y - _sage_const_1 ) * (n - y) / _sage_const_2  + x - y - _sage_const_1 

def _count(n):
    return n * (n + _sage_const_1 ) / _sage_const_2 

def _uncount(l):
    # Turns out this is the right expression o.O
    return (-_sage_const_1  + sqrt(_sage_const_1  + _sage_const_8  * float(l))) / _sage_const_2 

def _build_intersection_matrix(mats):
    # Generate our base intersection matrix
    blocks = []
    n = int(_uncount(len(mats))) + _sage_const_1 

    for i in range(n):
        blocks.append([])
        for j in range(n):
            if i == j:
                blocks[i].append(matrix(_g))
            elif i > j:
                blocks[i].append(-mats[_ind(j, i, len(mats), n)].transpose())
            else:
                blocks[i].append(mats[_ind(i, j, len(mats), n)])

    base_blocks = []

    for i in range(_sage_const_2 ):
        base_blocks.append([])
        for j in range(_sage_const_2 ):
            base_blocks[i].append(blocks[i][j])

    I = block_matrix(blocks)
    B = block_matrix(base_blocks)

    #print(f'Intersection matrix:\n{I}\n')

    assert I.is_skew_symmetric(), "Intersection matrix is not skew-symmetric"

    #print(f'{A}\n')

    return (blocks,I,n,B)

def _all_integers(v):
    return all(list(map(lambda x: x.is_integer(), v)))

def _build_kernel_generators(blocks, B, n):
    # Build the kernel of our map
    ker = np.zeros((_g * (n - _sage_const_2 ), _g * n))

    for i in range(_sage_const_2 , n):
        for j in range(_g):
            coeffs = B.inverse() * vector(QQ, [blocks[i][k][j][l]
                for k in range(_sage_const_2 ) for l in range(_g)])
            a = _sage_const_1  if _all_integers(coeffs) else _sage_const_1  / reduce(gcd, coeffs) 
            coeffs = a * coeffs

            assert _all_integers(coeffs), \
                    "Kernel generators cannot be given in integer coefficients"

            e = _g * (i - _sage_const_2 ) + j
            ker[e,:_g * _sage_const_2 ] = coeffs
            ker[e,e + _g * _sage_const_2 ] = a
            ker[e] = list(map(int, ker[e]))

    return ker

def _compute_q_form(I, ker):
    # Compute the intersection form
    Q = matrix(len(ker))

    for i,e1 in enumerate(ker):
        for j,e2 in enumerate(ker):
            s = _sage_const_0 
            for k in range(len(e1)):
                for l in range(k + _sage_const_1 , len(e2)):
                    s += (e1[k] * e2[l]) * I[k][l]
            Q[i,j] = s

    assert Q.is_symmetric(), \
            "Intersection form is not symmetric, this likely means the kernel "\
            "was generated incorrectly"

    return Q

def intersection_data(cuts, B=I4, M=J):
    """
    Given some elements of (?), find the intersection data using
    basis B.
    :param T: Basis of Lagrangian decomposition in the form of a symplectic
    matrix
    :param B: Initial Lagrangian decomposition, by default this is the 4x4
    identity matrix
    :param M: The (symplectic) intersection pairing for the given basis, by
    default this is J
    :return: A block matrix of intersection data
    """
    global _g

    assert B.nrows() == B.ncols() == _sage_const_4 , \
            f'B needs to be 4x4, but got {B.nrows()}x{B.cols()} instead'

    _g = _sage_const_2 

    dim = len(cuts) - _sage_const_1 
    I = matrix(len(cuts) * _sage_const_2 )

    for i in range(I.nrows()):
        for j in range(I.ncols()):
            I[i,j] = (matrix(cuts[i//_sage_const_2 ][i%_sage_const_2 ]) * M * cuts[j//_sage_const_2 ][j%_sage_const_2 ])[_sage_const_0 ]
    
    mats = [I[i:i+_sage_const_2 ,j:j+_sage_const_2 ]
            for i in range(_sage_const_0 , I.nrows() - _sage_const_2 , _sage_const_2 )
            for j in range(i + _sage_const_2 , I.ncols(), _sage_const_2 )]

    return mats

def intersection_form(g, mats):
    """
    Solve for the intersection form given a multisection
    :param int g: Genus of the multisection diagram
    :param list[list[int]] mats: Blocks of the intersection matrix, in the \
            form e.g. (a, b), (a, c), (b, c) where (a, b) looks like \
             [[<a_1, b_1>, ..., <a_1, b_g>],
              [     ⁞    ,  ⋱ ,     ⁞     ],
              [<a_g, b_1>, ..., <a_g, b_g>]]
    :return: Returns the intersection form
    """
    global _g
    _g = g
    mats = list(map(matrix, mats))

    # Standard assertions
    assert _g >= _sage_const_0 , "Genus must be >= 0"
    for i,mat in enumerate(mats):
        assert mat.ncols() == mat.nrows() == _g, \
                f"The block\n{mat}\nshould be {_g}x{_g}, but is actually " \
                f"{mat.nrows()}x{mat.ncols()}"
    assert _uncount(len(mats)).is_integer(), \
            "Intersection blocks don't fit into skew-symmetric matrix"

    blocks,I,n,B = _build_intersection_matrix(mats)
    #print(f'Intersection matrix:\n{I}\n')
    ker = _build_kernel_generators(blocks, B, n)
    #print(f'Kernel generators:\n{matrix(ZZ, ker)}\n')

    return _compute_q_form(I, ker)

def signature(B):
    """
    Find the signature of a bilinear form given its matrix representation.
    :param matrix: Matrix representation of a bilinear form B
    :return: Returns the signature of B
    """
    Q = QuadraticForm(ZZ, B + B.transpose())
    return Q.signature_vector()

def definiteness(B):
    Q = QuadraticForm(ZZ, B + B.transpose())
    return Q.compute_definiteness_string_by_determinants()

def parity(B):
    Q = QuadraticForm(ZZ, B + B.transpose())
    return Q.parity()

def random_symplectic_matrix():
    transvection = matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]])
    rotation     = matrix([[_sage_const_0 ,_sage_const_0 ,-_sage_const_1 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]])
    mix          = matrix([[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,-_sage_const_1 ,_sage_const_1 ,_sage_const_0 ],[-_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ]])
    swap         = matrix([[_sage_const_0 ,_sage_const_1 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_1 ,_sage_const_0 ,_sage_const_0 ,_sage_const_0 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_0 ,_sage_const_1 ],[_sage_const_0 ,_sage_const_0 ,_sage_const_1 ,_sage_const_0 ]])

    P = [random.choice([transvection, rotation, mix, swap])
            for _ in range(random.randint(_sage_const_1 ,_sage_const_10 ))]
    M = reduce(lambda a, x: a * x, P)

    assert M in Sp4, "Generated matrix is not in Sp(Z, 4)"

    return (M, P)

def random_unimodular_matrix(n):
    matrix_space = sage.matrix.matrix_space.MatrixSpace(ZZ, n)
    return sage.matrix.constructor.random_unimodular_matrix(matrix_space,
            upper_bound=_sage_const_3 )

def random_diagram(n, B=I4, M=J):
    """
    Generate a random genus 2 multisection diagram with n + 2 cut systems,
    the first two being the standard alpha and beta cut systems.
    """
    while True:
        cuts = [(B.column(_sage_const_0 ), B.column(_sage_const_1 )), (B.column(_sage_const_2 ), B.column(_sage_const_3 ))]

        # Bare minimum, pick a complement that we haven't seen yet
        for _ in range(n):
            new_cut = matrix(_sage_const_4 )
            while new_cut[_sage_const_0 :_sage_const_2 ,_sage_const_2 :_sage_const_4 ].determinant() == _sage_const_0 :
                new_cut = random_symplectic_matrix()[_sage_const_0 ]
            #basis = matrix((cuts[-1][0], cuts[-1][1], new_cut * cuts[-1][0], new_cut * cuts[-1][1])).transpose()
            #new_cut = basis * new_cut
            cuts.append((new_cut * cuts[-_sage_const_1 ][_sage_const_0 ], new_cut * cuts[-_sage_const_1 ][_sage_const_1 ]))

        if matrix([cuts[-_sage_const_1 ][_sage_const_0 ], cuts[-_sage_const_1 ][_sage_const_1 ], cuts[_sage_const_0 ][_sage_const_0 ], cuts[_sage_const_0 ][_sage_const_1 ]]).determinant() != _sage_const_0 :
            break

    return cuts

if __name__ == "__main__":
    mats = [
        [[_sage_const_1 , _sage_const_0 ], [_sage_const_0 , _sage_const_1 ]],
        [[_sage_const_1 , _sage_const_0 ], [_sage_const_0 , _sage_const_1 ]],
        [[-_sage_const_1 , _sage_const_0 ], [_sage_const_0 , -_sage_const_1 ]],
    ]

    #intersection_form(2, mats)
    _compute_q_form([], [])

